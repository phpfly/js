<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
<script type="text/javascript">
	//构造函数模式的目的就是为了创建一个自定义类，并且创建 这个类的实例


	//构造函数模式和工厂模式的区别？
	//1.执行的时候  普通函数执行--》createJsPerson()
    //               构造函数模式--》new createJsPerson()  通过new 执行后 ，我们的createJsPerson就是类名了  p1就是CreateJsPerson的一个实例

    //js中所有的类都是函数数据类型的  所有的实例都是对象数据类型的

    //2.在函数代码执行的时候 
    //相同：都是形成一个私有的作用域，然后 形参赋值--》预解释--》代码从上到下执行（类和普通函数一样，也有普通函数的一面）
    //不同：在代码执行之前，不要自己手动的创建对象了，浏览器会默认的创建一个对象数据类型的值（这个对象其实就是我们当前类的一个实例），接下来，代码从上到下执行，以当前实例为执行的主体（this代表的就是当前的实例），然后分别把属性名和属性值赋值给当前的实例  最后浏览器会默认把创建的实例返回


    function CreateJsPerson(name, age) {
    	//浏览器创建的对象就是我们的实例p1--》this
    	this.name = name;
    	this.age = age;
    	this.writeJs = function() {
    		console.log('hello');
    	};
    	//浏览器在把创建的实例默认的进行返回
    }
 
    var p1 = new CreateJsPerson('王小波', 48);
    p1.name;





    //创建一个数组
    var ary = [];  //字面量方式
    var ary = new Array(); //实例创建的方式--》构造函数模式执行方式
    //不管哪种方式 ary都是Array这个类的一个实例



 //2.在构造函数模式中，类中(函数中)出现的this.** 是当前类的实例


 //3.p1和p2都是CreateJsPerson这个类的实例，所以都拥有writeJs这个方法，但是不同实例之间的方法是不一样的

 	var res = CreateJsPerson('**', 18);
 	//这样写不是构造函数执行而是普通的函数执行，由于没有写return 所以res=undefined，并且CreateJsPerson这个方法中的this 是window

</script>
</body>
</html>